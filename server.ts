import { render as renderEmail, toPlainText } from '@react-email/render'
import bodyParser from 'body-parser'
import cors from 'cors'
import express from 'express'
import { createElement, type ReactElement } from 'react' // generated by gen:templates

import {
  type EmailRenderPayload,
  type EmailVariableType,
  type TemplateModules,
  templates,
} from './emails/index'

const app = express()

// TODO: Important, Remove this after cloning
const liveDemoUrl = 'https://email-live-stage.lovable.app'
app.use(
  cors({
    origin: [liveDemoUrl],
  })
)

app.use(bodyParser.json({ limit: '1mb' }))

// Shared: resolve the requested email component into a React element
type ResolveSuccess = { status: 200; element: ReactElement }
type ResolveError = { status: 400; error: string; description?: string }

function resolveEmailElement<M extends keyof TemplateModules, T extends keyof TemplateModules[M]>(
  body: EmailRenderPayload<M, T>
): ResolveSuccess | ResolveError {
  const _body = (body || {}) as EmailRenderPayload<M, T>
  const { emailModule, template, variables } = _body

  if (!emailModule || !template) {
    return { status: 400, error: 'Missing emailModule or template' }
  }

  const reqMsg = `Email Render Request: (${String(emailModule)} | ${String(template)})`

  const moduleMap = templates[emailModule] as TemplateModules[M]

  if (!moduleMap) {
    return {
      status: 400,
      error: `Unknown emailModule: ${String(emailModule)}`,
      description: `Use one of: ${Object.keys(templates)}`,
    }
  }

  const entry = moduleMap[template] as TemplateModules[M][T]
  if (!entry) {
    return {
      status: 400,
      error: `Unknown template: ${String(template)}.`,
      description: `Use one of: ${Object.keys(moduleMap)}`,
    }
  }

  // Narrow the entry/component/variables relationship for React.createElement
  // Ensure props satisfy React's `P extends {}` constraint without loosening types
  type Props = EmailVariableType<M, T> & {}
  const component = (
    entry as unknown as {
      component: React.ComponentType<Props>
    }
  ).component
  const element = createElement<Props>(component, variables as Props)

  return { status: 200, element }
}

// JSON endpoint (backwards-compatible): returns { html, text }
app.post('/api/render', async (req, res) => {
  try {
    const resolved = resolveEmailElement(req.body as EmailRenderPayload)
    if (resolved.status !== 200) {
      const { status, ...payload } = resolved
      return res.status(status).json(payload)
    }
    const { element } = resolved

    const html = await renderEmail(element)
    const text = toPlainText(html)

    return res.status(200).json({ html: String(html), text })
  } catch (err) {
    console.error('/api/render error', err)
    return res.status(500).json({ error: 'Failed to render' })
  }
})

// Raw HTML endpoint: returns text/html body
app.post('/api/render/html', async (req, res) => {
  try {
    const resolved = resolveEmailElement(req.body as EmailRenderPayload)
    if (resolved.status !== 200) {
      const { status, ...payload } = resolved
      // Return plain text for errors to match content type expectations
      return res
        .status(status)
        .type('text/plain')
        .send(payload.error || 'Bad Request')
    }
    const { element } = resolved

    const html = await renderEmail(element)
    return res.type('html').status(200).send(html)
  } catch (err) {
    console.error('/api/render/html error', err)
    return res.status(500).type('text/plain').send('Failed to render')
  }
})

// Plain text endpoint: returns text/plain body
app.post('/api/render/text', async (req, res) => {
  try {
    const resolved = resolveEmailElement(req.body as EmailRenderPayload)
    if (resolved.status !== 200) {
      const { status, ...payload } = resolved
      return res
        .status(status)
        .type('text/plain')
        .send(payload.error || 'Bad Request')
    }
    const { element } = resolved

    const html = await renderEmail(element)
    const text = toPlainText(html)
    return res.type('text').status(200).send(text)
  } catch (err) {
    console.error('/api/render/text error', err)
    return res.status(500).type('text/plain').send('Failed to render')
  }
})

// Health checks
app.get('/health', (_req, res) => res.status(200).send('ok'))

// TODO: Important, Remove this after cloning
app.get('/', (_req, res) => {
  res.redirect(liveDemoUrl)
})

// Cloud Run provides PORT via env var
const PORT = process.env.PORT || 8080
app.listen(PORT, () => {
  console.log(`Server listening on port ${PORT}`)
})
